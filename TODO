TODO list (in order of priority)
---------

- rename
- handling of most file system metadata
  - ownership: how is this done depending on
    per-user or root mounts? think about security
    here!
  - extended attributes
- size -> bigint, adapt also code!
- sort out synchronization issues, how much should we lock?
- add tests for sparse files and funny read/write operations
- strategy for half-blocks, help PostgreSQL optimize disk usage
  of data in BYTEA columns. Try to support tails of growing files
  and tiny files (without padding to the block size)
- make block size detectable per file (there is no reason why
  different files should not have a different block size)
- allow for size_t and off_t (check int4 which should
  be int8, use be64ton and not htonl), flag for 64-bit
  (large filesystem)?
- establish self-containment (with respect to
  a temporarily unavailable Postgresql server)
- minimal SELinux support, i.e. one fix security context
  per mount point
  unique: 8, opcode: GETXATTR (22), nodeid: 7, insize: 68
  unique: 8, error: -38 (Function not implemented), outsize: 16
  lsetxattr("file.sgml", "security.selinux", "system_u:object_r:httpd_sys_content_t:s0", 41, 0) = -1 EOPNOTSUPP (Operation not supported)
  - investigate SELinux races
  - make some performance tests, see http://archive09.linux.com/feature/127055
- add options to specify:
  - prefix for tables and indexes
  - a --init and a --clean option, using schema.sql as template?
  - support options to specify names of tables, prefixes or/and namespaces?
- optimizations:
  - use prepared statements, measure performance gain
  - use of asynchonous read/writes
  - optimize using .flag_nullpath_ok = 1, check functions if they can live without
    path (but for verbosity and error messages), maybe add path to PgFuseFile
  - make table names options, in order to store many pgfuse filesystems in one
    database
  
  
