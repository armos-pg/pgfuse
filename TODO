TODO list (in order of priority)
---------

- handling of most file system metadata
  - ownership: how is this done depending on
    per-user or root mounts? think about security
    here!
  - extended attributes
- remove the size limitations, change the storage to
  a bytea (in blocks) as in mysqlfs.
- pooling of PQconn
  - our own, thread-synchronized pooling?
  - use pgpool? has secondary benefits like a replicated filesystem for
    free
- thread-synchronization (we can ommit the -s flag)
- replace dir.path with a range search tree algo in DB
- rename (after a redo of the dir table)
- use of asynchonous read/writes
- what is a transaction? couple to fsync/fdatasync
  for files? other ideas? customizable?
- use prepared statements, measure performance gain
- establish self-containment (with respect to
  a temporarily unavailable Postgresql server)
- minimal SELinux support, i.e. one fix security context
  per mount point
  unique: 8, opcode: GETXATTR (22), nodeid: 7, insize: 68
  unique: 8, error: -38 (Function not implemented), outsize: 16
  lsetxattr("file.sgml", "security.selinux", "system_u:object_r:httpd_sys_content_t:s0", 41, 0) = -1 EOPNOTSUPP (Operation not supported)
  - investigate SELinux races
  - make some performance tests, see http://archive09.linux.com/feature/127055
- optimize using .flag_nullpath_ok = 1, check functions if they can live without
  path (but for verbosity and error messages), maybe add path to PgFuseFile
- make table names options, in order to store many pgfuse filesystems in one
  database
  
  
