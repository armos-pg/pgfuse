TODO list (in order of priority)
---------

- integrate statfs patch:
  - calculating the size:
    a) virtual things like real blocks and inodes
    b) select physical things in db:
       http://www.postgresql.org/docs/current/interactive/functions-admin.html#FUNCTIONS-ADMIN-DBSIZE
  - Can't do this, as the db user must be underprivileged:
    show data_directory;
    /var/lib/postgres/data
    ERROR:  must be superuser to examine "data_directory"
    This is for objects in the default tablespace
    1) get list of oids containing the data of the tables/indexes
       SELECT oid FROM pg_class WHERE relname = 'dir' AND relkind = 'r';
       select 'dir'::regclass::oid;
    3) use default data dir or tablespace location to resolve the path
       SELECT reltablespace FROM pg_class WHERE relname = 'dir' AND relkind = 'r';
       => 0, means default tablespace of the database, so we have to ask
       the database:
       datname?
       
    
       select datname,dattablespace from pg_database;
       select spclocation from pg_tablespace where oid = 
       >= 9.2  
       select pg_tablespace_location('55025');
       
    other ways:

       explicit tablespace in create table:
   SELECT d.datname as "Name",
       r.rolname as "Owner",
       pg_catalog.pg_encoding_to_char(d.encoding) as "Encoding",
       pg_catalog.shobj_description(d.oid, 'pg_database') as "Description",
       t.spcname as "Tablespace"
FROM pg_catalog.pg_database d
  JOIN pg_catalog.pg_roles r ON d.datdba = r.oid
  JOIN pg_catalog.pg_tablespace t on d.dattablespace = t.oid
ORDER BY 1;


    
--    COALESCE(TS.spclocation, XS.spclocation, '') AS "location"
    SELECT N.nspname || '.' || C.relname AS "relation",
    CASE WHEN reltype = 0
        THEN pg_size_pretty(pg_total_relation_size(C.oid)) || ' (index)'
        ELSE pg_size_pretty(pg_total_relation_size(C.oid)) || ' (' ||  pg_size_pretty(pg_relation_size(C.oid)) || ' data)'
    END AS "size (data)",
    COALESCE(T.tablespace, I.tablespace, '') AS "tablespace"
FROM pg_class C
LEFT JOIN pg_namespace N ON  (N.oid = C.relnamespace)
LEFT JOIN pg_tables T ON (T.tablename = C.relname)
LEFT JOIN pg_indexes I ON (I.indexname = C.relname)
LEFT JOIN pg_tablespace TS ON TS.spcname = T.tablespace
LEFT JOIN pg_tablespace XS ON XS.spcname = I.tablespace
WHERE nspname NOT IN ('pg_catalog','pg_toast','information_schema')
ORDER BY pg_total_relation_size(C.oid) DESC;


default case: 
$PGDATA/base 

  - no Perl, Shell, Posix df dependency
- handling of most file system metadata
  - ownership: how is this done depending on
    per-user or root mounts? think about security
    here!
  - extended attributes
  - how much access control is possible if not using default_permissions:
    - group membership doesn't work (design limitation in FUSE)
    - Selinux will not work because we can't assign parallel contexts,
      maybe forcing a security context mount option is an option, but
      so far the fuse mount helper doesn't pass the Selinux mount option
      to the kernel
- fill in st_nlink correctly
- strategy for half-blocks, help PostgreSQL optimize disk usage
  of data in BYTEA columns. Try to support tails of growing files
  and tiny files (without padding to the block size)
- establish self-containment (with respect to
  a temporarily unavailable Postgresql server)
- minimal SELinux support, i.e. one fix security context
  per mount point
  unique: 8, opcode: GETXATTR (22), nodeid: 7, insize: 68
  unique: 8, error: -38 (Function not implemented), outsize: 16
  lsetxattr("file.sgml", "security.selinux", "system_u:object_r:httpd_sys_content_t:s0", 41, 0) = -1 EOPNOTSUPP (Operation not supported)
  - investigate SELinux races
  - make some performance tests, see http://archive09.linux.com/feature/127055
- add options to specify:
  - prefix for tables and indexes
  - a --init and a --clean option, using schema.sql as template?
  - support options to specify names of tables, prefixes or/and namespaces?
- optimizations:
  - use prepared statements, measure performance gain
  - use of asynchonous read/writes
  - optimize using .flag_nullpath_ok = 1, check functions if they can live without
    path (but for verbosity and error messages), maybe add path to PgFuseFile
  - make table names options, in order to store many pgfuse filesystems in one
    database
  
  
